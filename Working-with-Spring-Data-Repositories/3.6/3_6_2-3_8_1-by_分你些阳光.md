20171209第一周任务

---

#### 3.6.2. 定制repository基类

当你想要定制repository基类时，上述方法需要自定义所有repository接口，从而所有repository都受到影响。 如果要更改所有repository的行为，您需要实现一个扩展持久性技术特定的repository基类的接口。 此类将作为代理repository的自定义repository基类。

Example 35. 自定义repository基类

```java
class MyRepositoryImpl<T, ID extends Serializable>
  extends SimpleJpaRepository<T, ID> {

  private final EntityManager entityManager;

  MyRepositoryImpl(JpaEntityInformation entityInformation,
                          EntityManager entityManager) {
    super(entityInformation, entityManager);

    // Keep the EntityManager around to used from the newly introduced methods.
    this.entityManager = entityManager;
  }

  @Transactional
  public <S extends T> S save(S entity) {
    // implementation goes here
  }
}
```

> 该类需要具有特定于存储库的工厂实现使用的超类的构造函数。 如果存储库基类具有多个构造函数，则覆盖采用EntityInformation和存储特定基础结构对象（例如EntityManager或模板类）的构造函数。

最后一步是让Spring Data基础设施知道定制的repository基类。 在JavaConfig中，这是通过使用@Enable ... Repositories注释的repositoryBaseClass属性来实现的：

Example 36. 使用JavaConfig来配置自定义的repository基类

```
@Configuration
@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)
class ApplicationConfiguration { … }
```

XML名称空间中提供了相应的属性。

Example 37. 使用XML配置自定义存储库基类

```
<repositories base-package="com.acme.repository"
     base-class="….MyRepositoryImpl" />
```

### 3.7. 从聚合根处发布事件

由respositories管理的实体是聚合根。 在“域驱动设计”的应用程序中，这些聚合根通常用来发布域事件。 Spring Data提供了一个注解@DomainEvents，您可以在聚合根的方法上使用该方法使该发布尽可能地简单。

Example 38. Exposing domain events from an aggregate root

```
class AnAggregateRoot {

    @DomainEvents 
    Collection<Object> domainEvents() {
        // … return events you want to get published here
    }

    @AfterDomainEventPublication 
    void callbackMethod() {
       // … potentially clean up domain events list
    }
}
```

> 1. 使用@DomainEvents的方法可以返回单个事件实例或一组事件。 它不能有任何争论。
> 2. 在所有事件发布之后，用@AfterDomainEventPublication注解的方法。 例如 可以用来潜在地清理要发布的事件列表。

每次Spring Data repository的`save(…)`这个方法启动时，这个方法都会启动。

### 3.8. Spring Data 的拓展

本节记录了一系列Spring Data的扩展，它们可以在各种上下文中启用Spring Data。目前大多数集成都是针对Spring MVC的。

#### 3.8.1. Querydsl 拓展

[Querydsl]((http://www.querydsl.com/))是一个框架，它可以通过流畅的API构建静态类型的SQL查询。

几个Spring Data模块通过提供`QueryDslPredicateExecutor`与Querydsl进行集成。

Example 39. QueryDslPredicateExecutor 接口

```java
public interface QueryDslPredicateExecutor<T> {

  Optional<T> findById(Predicate predicate);  

  Iterable<T> findAll(Predicate predicate);   

  long count(Predicate predicate);            

  boolean exists(Predicate predicate);        

  // … more functionality omitted.
}
```

> 1. 找到并返回匹配到Predicate的一个单个实体
> 2. 找到并返回匹配到Predicate的所有实体
> 3. 返回匹配到Predicate的所有实体的数目
> 4. 返回是否存在匹配到Predicate的实体

在你的respository接口上简单地继承`QueryDslPredicateExecutor`就可以支持使用Querydsl

Example 40. Querydsl在repositories上的集成

```java
interface UserRepository extends CrudRepository<User, Long>, QueryDslPredicateExecutor<User> {

}
```

上述操作可以使你使用Querydsl Predicate s编写类型安全的语句

```java
Predicate predicate = user.firstname.equalsIgnoreCase("dave")
	.and(user.lastname.startsWithIgnoreCase("mathews"));

userRepository.findAll(predicate);
```